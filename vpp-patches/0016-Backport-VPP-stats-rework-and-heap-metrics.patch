From be405d28fb590c590c3fca199090120df54b3799 Mon Sep 17 00:00:00 2001
From: Ole Troan <ot@cisco.com>
Date: Thu, 18 Mar 2021 11:12:01 +0100
Subject: [PATCH] [Backport] VPP stats rework and heap metrics

---
 src/plugins/urpf/ip4_urpf.c              |   2 +-
 src/plugins/urpf/ip6_urpf.c              |   2 +-
 src/plugins/urpf/test/test_urpf.py       |  30 +-
 src/vlib/stat_weak_inlines.h             |   6 +
 src/vlib/threads.c                       |   5 +-
 src/vnet/ipsec/ah_encrypt.c              |   9 +-
 src/vpp-api/client/stat_client.c         |  55 +-
 src/vpp-api/python/vpp_papi/vpp_stats.py | 835 +++++++++++++++--------
 src/vpp/CMakeLists.txt                   |   1 +
 src/vpp/stats/stat_segment.c             | 371 +++++++---
 src/vpp/stats/stat_segment.h             |  48 +-
 src/vpp/stats/stat_segment_provider.c    | 121 ++++
 src/vpp/stats/stat_segment_shared.h      |   6 +
 src/vppinfra/mem_dlmalloc.c              |  17 +-
 test/framework.py                        |   3 +-
 test/template_ipsec.py                   |   5 +-
 test/test_ipsec_tun_if_esp.py            | 134 ++--
 test/test_stats_client.py                | 100 ++-
 test/vpp_interface.py                    |   8 +-
 test/vpp_neighbor.py                     |   2 +-
 20 files changed, 1206 insertions(+), 554 deletions(-)
 mode change 100644 => 100755 src/vpp-api/python/vpp_papi/vpp_stats.py
 create mode 100644 src/vpp/stats/stat_segment_provider.c

diff --git a/src/plugins/urpf/ip4_urpf.c b/src/plugins/urpf/ip4_urpf.c
index 25b6c94bd..1d3290294 100644
--- a/src/plugins/urpf/ip4_urpf.c
+++ b/src/plugins/urpf/ip4_urpf.c
@@ -41,7 +41,7 @@
 #include <urpf/urpf_dp.h>
 
 static char *ip4_urpf_error_strings[] = {
-#define _(a,b) "ip4-" # b,
+#define _(a, b) b,
   foreach_urpf_error
 #undef _
 };
diff --git a/src/plugins/urpf/ip6_urpf.c b/src/plugins/urpf/ip6_urpf.c
index 3a94a456c..48d991573 100644
--- a/src/plugins/urpf/ip6_urpf.c
+++ b/src/plugins/urpf/ip6_urpf.c
@@ -41,7 +41,7 @@
 #include <urpf/urpf_dp.h>
 
 static char *ip6_urpf_error_strings[] = {
-#define _(a,b) "ip6-" # b,
+#define _(a, b) b,
   foreach_urpf_error
 #undef _
 };
diff --git a/src/plugins/urpf/test/test_urpf.py b/src/plugins/urpf/test/test_urpf.py
index 64b246cd6..8f4e563f8 100644
--- a/src/plugins/urpf/test/test_urpf.py
+++ b/src/plugins/urpf/test/test_urpf.py
@@ -90,7 +90,8 @@ class TestURPF(VppTestCase):
         # packets from address to which there is no route are dropped
         self.send_and_assert_no_replies(self.pg0, p_spoof_loose)
 
-        self.assert_error_counter_equal("ip4-rx-urpf-loose", N_PKTS)
+        self.assert_error_counter_equal("/err/ip4-rx-urpf-loose/uRPF Drop",
+                                        N_PKTS)
 
         #
         # crank it up to strict mode
@@ -106,7 +107,8 @@ class TestURPF(VppTestCase):
         self.send_and_assert_no_replies(self.pg0, p_spoof_strict)
         self.send_and_assert_no_replies(self.pg0, p_spoof_loose)
 
-        self.assert_error_counter_equal("ip4-rx-urpf-strict", 2 * N_PKTS)
+        self.assert_error_counter_equal("/err/ip4-rx-urpf-strict/uRPF Drop",
+                                        2 * N_PKTS)
 
         #
         # disable uRPF, all traffic should pass
@@ -136,7 +138,8 @@ class TestURPF(VppTestCase):
         self.send_and_expect(self.pg0, p_spoof_strict, self.pg1)
         self.send_and_assert_no_replies(self.pg0, p_spoof_loose)
 
-        self.assert_error_counter_equal("ip4-tx-urpf-loose", N_PKTS)
+        self.assert_error_counter_equal("/err/ip4-tx-urpf-loose/uRPF Drop",
+                                        N_PKTS)
 
         self.vapi.urpf_update(is_input=False,
                               mode=e.vl_api_urpf_mode_t.URPF_API_MODE_STRICT,
@@ -149,7 +152,8 @@ class TestURPF(VppTestCase):
         self.send_and_expect(self.pg0, p_spoof_strict, self.pg1)
         self.send_and_assert_no_replies(self.pg0, p_spoof_loose)
 
-        self.assert_error_counter_equal("ip4-tx-urpf-strict", N_PKTS)
+        self.assert_error_counter_equal("/err/ip4-tx-urpf-strict/uRPF Drop",
+                                        N_PKTS)
 
         # change the strict packet so that it would forward through pg1
         p_spoof_strict = (Ether(dst=self.pg0.local_mac,
@@ -160,7 +164,8 @@ class TestURPF(VppTestCase):
                           Raw(b'\xa5' * 100)) * N_PKTS
 
         self.send_and_assert_no_replies(self.pg0, p_spoof_strict)
-        self.assert_error_counter_equal("ip4-tx-urpf-strict", 2 * N_PKTS)
+        self.assert_error_counter_equal("/err/ip4-tx-urpf-strict/uRPF Drop",
+                                        2 * N_PKTS)
 
         # cleanup
         self.vapi.urpf_update(is_input=False,
@@ -212,7 +217,8 @@ class TestURPF(VppTestCase):
         # packets from address to which there is no route are dropped
         self.send_and_assert_no_replies(self.pg0, p_spoof_loose)
 
-        self.assert_error_counter_equal("ip6-rx-urpf-loose", N_PKTS)
+        self.assert_error_counter_equal("/err/ip6-rx-urpf-loose/uRPF Drop",
+                                        N_PKTS)
 
         #
         # crank it up to strict mode
@@ -228,7 +234,8 @@ class TestURPF(VppTestCase):
         self.send_and_assert_no_replies(self.pg0, p_spoof_strict)
         self.send_and_assert_no_replies(self.pg0, p_spoof_loose)
 
-        self.assert_error_counter_equal("ip6-rx-urpf-strict", 2 * N_PKTS)
+        self.assert_error_counter_equal("/err/ip6-rx-urpf-strict/uRPF Drop",
+                                        2 * N_PKTS)
 
         #
         # disable uRPF, all traffic should pass
@@ -258,7 +265,8 @@ class TestURPF(VppTestCase):
         self.send_and_expect(self.pg0, p_spoof_strict, self.pg1)
         self.send_and_assert_no_replies(self.pg0, p_spoof_loose)
 
-        self.assert_error_counter_equal("ip6-tx-urpf-loose", N_PKTS)
+        self.assert_error_counter_equal("/err/ip6-tx-urpf-loose/uRPF Drop",
+                                        N_PKTS)
 
         self.vapi.urpf_update(is_input=False,
                               mode=e.vl_api_urpf_mode_t.URPF_API_MODE_STRICT,
@@ -271,7 +279,8 @@ class TestURPF(VppTestCase):
         self.send_and_expect(self.pg0, p_spoof_strict, self.pg1)
         self.send_and_assert_no_replies(self.pg0, p_spoof_loose)
 
-        self.assert_error_counter_equal("ip6-tx-urpf-strict", N_PKTS)
+        self.assert_error_counter_equal("/err/ip6-tx-urpf-strict/uRPF Drop",
+                                        N_PKTS)
 
         # change the strict packet so that it would forward through pg1
         p_spoof_strict = (Ether(dst=self.pg0.local_mac,
@@ -282,7 +291,8 @@ class TestURPF(VppTestCase):
                           Raw(b'\xa5' * 100)) * N_PKTS
 
         self.send_and_assert_no_replies(self.pg0, p_spoof_strict)
-        self.assert_error_counter_equal("ip6-tx-urpf-strict", 2 * N_PKTS)
+        self.assert_error_counter_equal("/err/ip6-tx-urpf-strict/uRPF Drop",
+                                        2 * N_PKTS)
 
         # cleanup
         self.vapi.urpf_update(is_input=False,
diff --git a/src/vlib/stat_weak_inlines.h b/src/vlib/stat_weak_inlines.h
index a1311e864..a68566d0f 100644
--- a/src/vlib/stat_weak_inlines.h
+++ b/src/vlib/stat_weak_inlines.h
@@ -63,4 +63,10 @@ vlib_stats_delete_cm (void *notused)
 {
 }
 
+void vlib_stats_register_mem_heap (void *) __attribute__ ((weak));
+void
+vlib_stats_register_mem_heap (void *notused)
+{
+}
+
 #endif
diff --git a/src/vlib/threads.c b/src/vlib/threads.c
index 7efddff54..4b2e8b1f7 100644
--- a/src/vlib/threads.c
+++ b/src/vlib/threads.c
@@ -405,7 +405,7 @@ vlib_frame_queue_alloc (int nelts)
   return (fq);
 }
 
-void vl_msg_api_handler_no_free (void *) __attribute__ ((weak));
+void vl_msg_api_handler_no_free (void *) __attribute__((weak));
 void
 vl_msg_api_handler_no_free (void *v)
 {
@@ -686,6 +686,7 @@ start_workers (vlib_main_t * vm)
   u32 n_vlib_mains = tm->n_vlib_mains;
   u32 worker_thread_index;
   clib_mem_heap_t *main_heap = clib_mem_get_per_cpu_heap ();
+  vlib_stats_register_mem_heap (main_heap);
 
   vec_reset_length (vlib_worker_threads);
 
@@ -1382,7 +1383,7 @@ cpu_config (vlib_main_t * vm, unformat_input_t * input)
 
 VLIB_EARLY_CONFIG_FUNCTION (cpu_config, "cpu");
 
-void vnet_main_fixup (vlib_fork_fixup_t which) __attribute__ ((weak));
+void vnet_main_fixup (vlib_fork_fixup_t which) __attribute__((weak));
 void
 vnet_main_fixup (vlib_fork_fixup_t which)
 {
diff --git a/src/vnet/ipsec/ah_encrypt.c b/src/vnet/ipsec/ah_encrypt.c
index d89cb093f..5c00141bf 100644
--- a/src/vnet/ipsec/ah_encrypt.c
+++ b/src/vnet/ipsec/ah_encrypt.c
@@ -38,11 +38,10 @@ typedef enum
     AH_ENCRYPT_N_NEXT,
 } ah_encrypt_next_t;
 
-#define foreach_ah_encrypt_error                                \
- _(RX_PKTS, "AH pkts received")                                 \
- _(CRYPTO_ENGINE_ERROR, "crypto engine error (packet dropped)") \
- _(SEQ_CYCLED, "sequence number cycled")
-
+#define foreach_ah_encrypt_error                                              \
+  _ (RX_PKTS, "AH pkts received")                                             \
+  _ (CRYPTO_ENGINE_ERROR, "crypto engine error (packet dropped)")             \
+  _ (SEQ_CYCLED, "sequence number cycled (packet dropped)")
 
 typedef enum
 {
diff --git a/src/vpp-api/client/stat_client.c b/src/vpp-api/client/stat_client.c
index 018cce342..ab0d83fc9 100644
--- a/src/vpp-api/client/stat_client.c
+++ b/src/vpp-api/client/stat_client.c
@@ -174,7 +174,7 @@ stat_segment_heartbeat_r (stat_client_main_t * sm)
   stat_segment_access_t sa;
   stat_segment_directory_entry_t *ep;
 
-  /* Has directory been update? */
+  /* Has directory been updated? */
   if (sm->shared_header->epoch != sm->current_epoch)
     return 0;
   if (stat_segment_access_start (&sa, sm))
@@ -202,8 +202,29 @@ stat_segment_heartbeat (void)
    _v(v);                                             \
 })
 
+static counter_t *
+stat_vec_simple_init (counter_t c)
+{
+  counter_t *v = 0;
+  vec_add1 (v, c);
+  return v;
+}
+
+static vlib_counter_t *
+stat_vec_combined_init (vlib_counter_t c)
+{
+  vlib_counter_t *v = 0;
+  vec_add1 (v, c);
+  return v;
+}
+
+/*
+ * If index2 is specified copy out the column (the indexed value across all
+ * threads), otherwise copy out all values.
+ */
 static stat_segment_data_t
-copy_data (stat_segment_directory_entry_t * ep, stat_client_main_t * sm)
+copy_data (stat_segment_directory_entry_t * ep, u32 index2, char *name,
+	   stat_client_main_t * sm)
 {
   stat_segment_data_t result = { 0 };
   int i;
@@ -214,7 +235,8 @@ copy_data (stat_segment_directory_entry_t * ep, stat_client_main_t * sm)
   assert (sm->shared_header);
 
   result.type = ep->type;
-  result.name = strdup (ep->name);
+  result.name = strdup (name ? name : ep->name);
+
   switch (ep->type)
     {
     case STAT_DIR_TYPE_SCALAR_INDEX:
@@ -227,7 +249,10 @@ copy_data (stat_segment_directory_entry_t * ep, stat_client_main_t * sm)
       for (i = 0; i < vec_len (simple_c); i++)
 	{
 	  counter_t *cb = stat_segment_adjust (sm, simple_c[i]);
-	  result.simple_counter_vec[i] = stat_vec_dup (sm, cb);
+	  if (index2 != ~0)
+	    result.simple_counter_vec[i] = stat_vec_simple_init (cb[index2]);
+	  else
+	    result.simple_counter_vec[i] = stat_vec_dup (sm, cb);
 	}
       break;
 
@@ -237,7 +262,11 @@ copy_data (stat_segment_directory_entry_t * ep, stat_client_main_t * sm)
       for (i = 0; i < vec_len (combined_c); i++)
 	{
 	  vlib_counter_t *cb = stat_segment_adjust (sm, combined_c[i]);
-	  result.combined_counter_vec[i] = stat_vec_dup (sm, cb);
+	  if (index2 != ~0)
+	    result.combined_counter_vec[i] =
+	      stat_vec_combined_init (cb[index2]);
+	  else
+	    result.combined_counter_vec[i] = stat_vec_dup (sm, cb);
 	}
       break;
 
@@ -265,6 +294,14 @@ copy_data (stat_segment_directory_entry_t * ep, stat_client_main_t * sm)
       }
       break;
 
+    case STAT_DIR_TYPE_SYMLINK:
+      /* Gather info from all threads into a vector */
+      {
+	stat_segment_directory_entry_t *ep2;
+	ep2 = vec_elt_at_index (sm->directory_vector, ep->index1);
+	return copy_data (ep2, ep->index2, ep->name, sm);
+      }
+
     case STAT_DIR_TYPE_EMPTY:
       break;
 
@@ -390,7 +427,7 @@ stat_segment_dump_r (uint32_t * stats, stat_client_main_t * sm)
     {
       /* Collect counter */
       ep = vec_elt_at_index (sm->directory_vector, stats[i]);
-      vec_add1 (res, copy_data (ep, sm));
+      vec_add1 (res, copy_data (ep, ~0, 0, sm));
     }
 
   if (stat_segment_access_end (&sa, sm))
@@ -440,12 +477,16 @@ stat_segment_dump_entry_r (uint32_t index, stat_client_main_t * sm)
   stat_segment_data_t *res = 0;
   stat_segment_access_t sa;
 
+  /* Has directory been update? */
+  if (sm->shared_header->epoch != sm->current_epoch)
+    return 0;
+
   if (stat_segment_access_start (&sa, sm))
     return 0;
 
   /* Collect counter */
   ep = vec_elt_at_index (sm->directory_vector, index);
-  vec_add1 (res, copy_data (ep, sm));
+  vec_add1 (res, copy_data (ep, ~0, 0, sm));
 
   if (stat_segment_access_end (&sa, sm))
     return res;
diff --git a/src/vpp-api/python/vpp_papi/vpp_stats.py b/src/vpp-api/python/vpp_papi/vpp_stats.py
old mode 100644
new mode 100755
index 4b7a9bce8..e0d83b813
--- a/src/vpp-api/python/vpp_papi/vpp_stats.py
+++ b/src/vpp-api/python/vpp_papi/vpp_stats.py
@@ -1,320 +1,561 @@
 #!/usr/bin/env python3
-
-from __future__ import print_function
-from cffi import FFI
+#
+# Copyright (c) 2021 Cisco and/or its affiliates.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at:
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+'''
+This module implement Python access to the VPP statistics segment. It
+accesses the data structures directly in shared memory.
+VPP uses optimistic locking, so data structures may change underneath
+us while we are reading. Data is copied out and it's important to
+spend as little time as possible "holding the lock".
+
+Counters are stored in VPP as a two dimensional array.
+Index by thread and index (typically sw_if_index).
+Simple counters count only packets, Combined counters count packets
+and octets.
+
+Counters can be accessed in either dimension.
+stat['/if/rx'] - returns 2D lists
+stat['/if/rx'][0] - returns counters for all interfaces for thread 0
+stat['/if/rx'][0][1] - returns counter for interface 1 on thread 0
+stat['/if/rx'][0][1]['packets'] - returns the packet counter
+                                  for interface 1 on thread 0
+stat['/if/rx'][:, 1] - returns the counters for interface 1 on all threads
+stat['/if/rx'][:, 1].packets() - returns the packet counters for
+                                 interface 1 on all threads
+stat['/if/rx'][:, 1].sum_packets() - returns the sum of packet counters for
+                                     interface 1 on all threads
+stat['/if/rx-miss'][:, 1].sum() - returns the sum of packet counters for
+                                  interface 1 on all threads for simple counters
+'''
+
+import os
+import socket
+import array
+import mmap
+from struct import Struct
 import time
-
-ffi = FFI()
-ffi.cdef("""
-typedef uint64_t counter_t;
-typedef struct {
-  counter_t packets;
-  counter_t bytes;
-} vlib_counter_t;
-
-typedef enum {
-  STAT_DIR_TYPE_ILLEGAL = 0,
-  STAT_DIR_TYPE_SCALAR_INDEX,
-  STAT_DIR_TYPE_COUNTER_VECTOR_SIMPLE,
-  STAT_DIR_TYPE_COUNTER_VECTOR_COMBINED,
-  STAT_DIR_TYPE_ERROR_INDEX,
-  STAT_DIR_TYPE_NAME_VECTOR,
-} stat_directory_type_t;
-
-typedef struct
-{
-  stat_directory_type_t type;
-  union {
-    uint64_t index;
-    uint64_t value;
-    uint64_t *data;
-  };
-  char name[128]; // TODO change this to pointer to "somewhere"
-} stat_segment_directory_entry_t;
-
-typedef struct
-{
-  char *name;
-  stat_directory_type_t type;
-  union
-  {
-    double scalar_value;
-    counter_t *error_vector;
-    counter_t **simple_counter_vec;
-    vlib_counter_t **combined_counter_vec;
-    uint8_t **name_vector;
-  };
-} stat_segment_data_t;
-
-typedef struct
-{
-  uint64_t version;
-  void *base;
-  uint64_t epoch;
-  uint64_t in_progress;
-  stat_segment_directory_entry_t *directory_vector;
-  uint64_t **error_vector;
-} stat_segment_shared_header_t;
-
-typedef struct
-{
-  uint64_t current_epoch;
-  stat_segment_shared_header_t *shared_header;
-  stat_segment_directory_entry_t *directory_vector;
-  ssize_t memory_size;
-} stat_client_main_t;
-
-stat_client_main_t * stat_client_get(void);
-void stat_client_free(stat_client_main_t * sm);
-int stat_segment_connect_r (char *socket_name, stat_client_main_t * sm);
-int stat_segment_connect (char *socket_name);
-void stat_segment_disconnect_r (stat_client_main_t * sm);
-void stat_segment_disconnect (void);
-
-uint32_t *stat_segment_ls_r (uint8_t ** patterns, stat_client_main_t * sm);
-uint32_t *stat_segment_ls (uint8_t ** pattern);
-stat_segment_data_t *stat_segment_dump_r (uint32_t * stats,
-                                          stat_client_main_t * sm);
-stat_segment_data_t *stat_segment_dump (uint32_t * counter_vec);
-void stat_segment_data_free (stat_segment_data_t * res);
-
-double stat_segment_heartbeat_r (stat_client_main_t * sm);
-int stat_segment_vec_len(void *vec);
-uint8_t **stat_segment_string_vector(uint8_t **string_vector, char *string);
-char *stat_segment_index_to_name_r (uint32_t index, stat_client_main_t * sm);
-uint64_t stat_segment_version(void);
-uint64_t stat_segment_version_r(stat_client_main_t *sm);
-void free(void *ptr);
-void vac_mem_init (size_t size);
-""")  # noqa: E501
-
-
-# Utility functions
-def make_string_vector(api, strings):
-    vec = ffi.NULL
-    if type(strings) is not list:
-        strings = [strings]
-    for s in strings:
-        vec = api.stat_segment_string_vector(vec, ffi.new("char []",
-                                                          s.encode('utf-8')))
-    return vec
-
-
-def make_string_list(api, vec):
-    vec_len = api.stat_segment_vec_len(vec)
-    return [ffi.string(vec[i]) for i in range(vec_len)]
-
-
-# 2-dimensonal array of thread, index
-def simple_counter_vec_list(api, e):
-    vec = []
-    for thread in range(api.stat_segment_vec_len(e)):
-        len_interfaces = api.stat_segment_vec_len(e[thread])
-        if_per_thread = [e[thread][interfaces]
-                         for interfaces in range(len_interfaces)]
-        vec.append(if_per_thread)
-    return vec
-
-
-def vlib_counter_dict(c):
-    return {'packets': c.packets,
-            'bytes': c.bytes}
-
-
-def combined_counter_vec_list(api, e):
-    vec = []
-    for thread in range(api.stat_segment_vec_len(e)):
-        len_interfaces = api.stat_segment_vec_len(e[thread])
-        if_per_thread = [vlib_counter_dict(e[thread][interfaces])
-                         for interfaces in range(len_interfaces)]
-        vec.append(if_per_thread)
-    return vec
-
-
-def error_vec_list(api, e):
-    vec = []
-    for thread in range(api.stat_segment_vec_len(e)):
-        vec.append(e[thread])
-    return vec
-
-
-def name_vec_list(api, e):
-    return [ffi.string(e[i]).decode('utf-8') for i in
-            range(api.stat_segment_vec_len(e)) if e[i] != ffi.NULL]
-
-
-def stat_entry_to_python(api, e):
-    # Scalar index
-    if e.type == 1:
-        return e.scalar_value
-    if e.type == 2:
-        return simple_counter_vec_list(api, e.simple_counter_vec)
-    if e.type == 3:
-        return combined_counter_vec_list(api, e.combined_counter_vec)
-    if e.type == 4:
-        return error_vec_list(api, e.error_vector)
-    if e.type == 5:
-        return name_vec_list(api, e.name_vector)
-    raise NotImplementedError()
-
-
-class VPPStatsIOError(IOError):
-    message = "Stat segment client connection returned: " \
-              "%(retval)s %(strerror)s."
-
-    strerror = {-1: "Stat client couldn't open socket",
-                -2: "Stat client socket open but couldn't connect",
-                -3: "Receiving file descriptor failed",
-                -4: "mmap fstat failed",
-                -5: "mmap map failed"
-                }
-
-    def __init__(self, message=None, **kwargs):
-        if 'retval' in kwargs:
-            self.retval = kwargs['retval']
-            kwargs['strerror'] = self.strerror[int(self.retval)]
-
-        if not message:
-            try:
-                message = self.message % kwargs
-            except Exception:
-                message = self.message
-        else:
-            message = message % kwargs
-
-        super(VPPStatsIOError, self).__init__(message)
-
-
-class VPPStatsClientLoadError(RuntimeError):
-    pass
-
-
-class VPPStats:
-    VPPStatsIOError = VPPStatsIOError
-
+import unittest
+import re
+
+def recv_fd(sock):
+    '''Get file descriptor for memory map'''
+    fds = array.array("i")   # Array of ints
+    _, ancdata, _, _ = sock.recvmsg(0, socket.CMSG_LEN(4))
+    for cmsg_level, cmsg_type, cmsg_data in ancdata:
+        if cmsg_level == socket.SOL_SOCKET and cmsg_type == socket.SCM_RIGHTS:
+            fds.frombytes(cmsg_data[:len(cmsg_data) - (len(cmsg_data) % fds.itemsize)])
+    return list(fds)[0]
+
+VEC_LEN_FMT = Struct('I')
+def get_vec_len(stats, vector_offset):
+    '''Equivalent to VPP vec_len()'''
+    return VEC_LEN_FMT.unpack_from(stats.statseg, vector_offset - 8)[0]
+
+def get_string(stats, ptr):
+    '''Get a string from a VPP vector'''
+    namevector = ptr - stats.base
+    namevectorlen = get_vec_len(stats, namevector)
+    if namevector + namevectorlen >= stats.size:
+        raise ValueError('String overruns stats segment')
+    return stats.statseg[namevector:namevector+namevectorlen-1].decode('ascii')
+
+
+class StatsVector:
+    '''A class representing a VPP vector'''
+
+    def __init__(self, stats, ptr, fmt):
+        self.vec_start = ptr - stats.base
+        self.vec_len = get_vec_len(stats, ptr - stats.base)
+        self.struct = Struct(fmt)
+        self.fmtlen = len(fmt)
+        self.elementsize = self.struct.size
+        self.statseg = stats.statseg
+        self.stats = stats
+
+        if self.vec_start + self.vec_len * self.elementsize >= stats.size:
+            raise ValueError('Vector overruns stats segment')
+
+    def __iter__(self):
+        with self.stats.lock:
+            return self.struct.iter_unpack(self.statseg[self.vec_start:self.vec_start +
+                                                        self.elementsize*self.vec_len])
+
+    def __getitem__(self, index):
+        if index > self.vec_len:
+            raise ValueError('Index beyond end of vector')
+        with self.stats.lock:
+            if self.fmtlen == 1:
+                return self.struct.unpack_from(self.statseg, self.vec_start +
+                                               (index * self.elementsize))[0]
+            return self.struct.unpack_from(self.statseg, self.vec_start +
+                                           (index * self.elementsize))
+
+class VPPStats():
+    '''Main class implementing Python access to the VPP statistics segment'''
+    # pylint: disable=too-many-instance-attributes
+    shared_headerfmt = Struct('QPQQPP')
     default_socketname = '/run/vpp/stats.sock'
-    sharedlib_name = 'libvppapiclient.so'
 
     def __init__(self, socketname=default_socketname, timeout=10):
         self.socketname = socketname
         self.timeout = timeout
+        self.directory = {}
+        self.lock = StatsLock(self)
         self.connected = False
-        try:
-            self.api = ffi.dlopen(VPPStats.sharedlib_name)
-        except Exception:
-            raise VPPStatsClientLoadError("Could not open: %s" %
-                                          VPPStats.sharedlib_name)
-        self.api.vac_mem_init(0)
+        self.size = 0
+        self.last_epoch = 0
+        self.error_vectors = 0
+        self.statseg = 0
 
     def connect(self):
-        self.client = self.api.stat_client_get()
-
-        poll_end_time = time.time() + self.timeout
-        while time.time() < poll_end_time:
-            rv = self.api.stat_segment_connect_r(
-                self.socketname.encode('utf-8'), self.client)
-            # Break out if success or any other error than "no such file"
-            # (indicating that VPP hasn't started yet)
-            if rv == 0 or ffi.errno != 2:
-                self.connected = True
-                break
-
-        if rv != 0:
-            raise VPPStatsIOError(retval=rv)
-
-    def heartbeat(self):
-        if not self.connected:
-            self.connect()
-        return self.api.stat_segment_heartbeat_r(self.client)
+        '''Connect to stats segment'''
+        if self.connected:
+            return
+        sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
+        sock.connect(self.socketname)
 
-    def ls(self, patterns):
-        if not self.connected:
-            self.connect()
-        return self.api.stat_segment_ls_r(make_string_vector(self.api,
-                                                             patterns),
-                                          self.client)
+        mfd = recv_fd(sock)
+        sock.close()
 
-    def lsstr(self, patterns):
-        if not self.connected:
-            self.connect()
-        rv = self.api.stat_segment_ls_r(make_string_vector(self.api,
-                                                           patterns),
-                                        self.client)
+        stat_result = os.fstat(mfd)
+        self.statseg = mmap.mmap(mfd, stat_result.st_size, mmap.PROT_READ, mmap.MAP_SHARED)
+        socket.close(mfd)
+
+        self.size = stat_result.st_size
+        if self.version != 2:
+            raise Exception('Incompatbile stat segment version {}'
+                            .format(self.version))
 
-        if rv == ffi.NULL:
-            raise VPPStatsIOError()
-        return [ffi.string(self.api.stat_segment_index_to_name_r(
-            rv[i], self.client)).decode('utf-8')
-                for i in range(self.api.stat_segment_vec_len(rv))]
+        self.refresh()
+        self.connected = True
 
-    def dump(self, counters):
+    def disconnect(self):
+        '''Disconnect from stats segment'''
+        if self.connected:
+            self.statseg.close()
+            self.connected = False
+
+    @property
+    def version(self):
+        '''Get version of stats segment'''
+        return self.shared_headerfmt.unpack_from(self.statseg)[0]
+
+    @property
+    def base(self):
+        '''Get base pointer of stats segment'''
+        return self.shared_headerfmt.unpack_from(self.statseg)[1]
+
+    @property
+    def epoch(self):
+        '''Get current epoch value from stats segment'''
+        return self.shared_headerfmt.unpack_from(self.statseg)[2]
+
+    @property
+    def in_progress(self):
+        '''Get value of in_progress from stats segment'''
+        return self.shared_headerfmt.unpack_from(self.statseg)[3]
+
+    @property
+    def directory_vector(self):
+        '''Get pointer of directory vector'''
+        return self.shared_headerfmt.unpack_from(self.statseg)[4]
+
+    @property
+    def error_vector(self):
+        '''Get pointer of error vector'''
+        return self.shared_headerfmt.unpack_from(self.statseg)[5]
+
+    elementfmt = 'IQ128s'
+
+    def refresh(self, blocking=True):
+        '''Refresh directory vector cache (epoch changed)'''
+        directory = {}
+        directory_by_idx = {}
+        while True:
+            try:
+                with self.lock:
+                    for i, direntry in enumerate(StatsVector(self, self.directory_vector, self.elementfmt)):
+                        path_raw = direntry[2].find(b'\x00')
+                        path = direntry[2][:path_raw].decode('ascii')
+                        directory[path] = StatsEntry(direntry[0], direntry[1])
+                        directory_by_idx[i] = path
+                    self.last_epoch = self.epoch
+                    self.directory = directory
+                    self.directory_by_idx = directory_by_idx
+
+                    # Cache the error index vectors
+                    self.error_vectors = []
+                    for threads in StatsVector(self, self.error_vector, 'P'):
+                        self.error_vectors.append(StatsVector(self, threads[0], 'Q'))
+                    return
+            except IOError:
+                if not blocking:
+                    raise
+
+    def __getitem__(self, item, blocking=True):
         if not self.connected:
             self.connect()
-        stats = {}
-        rv = self.api.stat_segment_dump_r(counters, self.client)
-        # Raise exception and retry
-        if rv == ffi.NULL:
-            raise VPPStatsIOError()
-        rv_len = self.api.stat_segment_vec_len(rv)
-
-        for i in range(rv_len):
-            n = ffi.string(rv[i].name).decode('utf-8')
-            e = stat_entry_to_python(self.api, rv[i])
-            if e is not None:
-                stats[n] = e
-        return stats
-
-    def get_counter(self, name):
-        retries = 0
         while True:
             try:
-                d = self.ls(name)
-                s = self.dump(d)
-                if len(s) > 1:
-                    raise AttributeError('Matches multiple counters {}'
-                                         .format(name))
-                k, v = s.popitem()
-                return v
-            except VPPStatsIOError:
-                if retries > 10:
-                    return None
-                retries += 1
-
-    def get_err_counter(self, name):
-        """Get an error counter. The errors from each worker thread
-           are summed"""
-        return sum(self.get_counter(name))
+                if self.last_epoch != self.epoch:
+                    self.refresh(blocking)
+                with self.lock:
+                    return self.directory[item].get_counter(self)
+            except IOError:
+                if not blocking:
+                    raise
+
+    def __iter__(self):
+        return iter(self.directory.items())
+
+    def set_errors(self, blocking=True):
+        '''Return dictionary of error counters > 0'''
+        if not self.connected:
+            self.connect()
 
-    def disconnect(self):
-        try:
-            self.api.stat_segment_disconnect_r(self.client)
-            self.api.stat_client_free(self.client)
-            self.connected = False
-            del self.client
-        except AttributeError:
-            # no need to disconnect if we're not connected
-            pass
-
-    def set_errors(self):
-        '''Return all errors counters > 0'''
-        retries = 0
+        errors = {k:v for k, v in self.directory.items() if k.startswith("/err/")}
+        result = {}
         while True:
             try:
-                error_names = self.ls(['/err/'])
-                error_counters = self.dump(error_names)
-                break
-            except VPPStatsIOError:
-                if retries > 10:
-                    return None
-                retries += 1
-
-        return {k: sum(error_counters[k])
-                for k in error_counters.keys() if sum(error_counters[k])}
-
-    def set_errors_str(self):
+                if self.last_epoch != self.epoch:
+                    self.refresh(blocking)
+                with self.lock:
+                    for k, entry in errors.items():
+                        total = 0
+                        i = entry.value
+                        for per_thread in self.error_vectors:
+                            total += per_thread[i]
+                        if total:
+                            result[k] = total
+                return result
+            except IOError:
+                if not blocking:
+                    raise
+
+    def set_errors_str(self, blocking=True):
         '''Return all errors counters > 0 pretty printed'''
-        s = ['ERRORS:']
-        error_counters = self.set_errors()
+        error_string = ['ERRORS:']
+        error_counters = self.set_errors(blocking)
         for k in sorted(error_counters):
-            s.append('{:<60}{:>10}'.format(k, error_counters[k]))
-        return '%s\n' % '\n'.join(s)
+            error_string.append('{:<60}{:>10}'.format(k, error_counters[k]))
+        return '%s\n' % '\n'.join(error_string)
+
+    def get_counter(self, name, blocking=True):
+        '''Alternative call to __getitem__'''
+        return self.__getitem__(name, blocking)
+
+    def get_err_counter(self, name, blocking=True):
+        '''Return a single value (sum of all threads)'''
+        if not self.connected:
+            self.connect()
+        if name.startswith("/err/"):
+            while True:
+                try:
+                    if self.last_epoch != self.epoch:
+                        self.refresh(blocking)
+                    with self.lock:
+                        return sum(self.directory[name].get_counter(self))
+                except IOError:
+                    if not blocking:
+                        raise
+
+    def ls(self, patterns):
+        '''Returns list of counters matching pattern'''
+        # pylint: disable=invalid-name
+        if not self.connected:
+            self.connect()
+        regex = [re.compile(i) for i in patterns]
+        return [k for k, v in self.directory.items()
+                if any(re.match(pattern, k) for pattern in regex)]
+
+    def dump(self, counters, blocking=True):
+        '''Given a list of counters return a dictionary of results'''
+        if not self.connected:
+            self.connect()
+        result = {}
+        for cnt in counters:
+            result[cnt] = self.__getitem__(cnt,blocking)
+        return result
+
+class StatsLock():
+    '''Stat segment optimistic locking'''
+
+    def __init__(self, stats):
+        self.stats = stats
+        self.epoch = 0
+
+    def __enter__(self):
+        acquired = self.acquire(blocking=True)
+        assert acquired, "Lock wasn't acquired, but blocking=True"
+        return self
+
+    def __exit__(self, exc_type=None, exc_value=None, traceback=None):
+        self.release()
+
+    def acquire(self, blocking=True, timeout=-1):
+        '''Acquire the lock. Await in progress to go false. Record epoch.'''
+        self.epoch = self.stats.epoch
+        if timeout > 0:
+            start = time.monotonic()
+        while self.stats.in_progress:
+            if not blocking:
+                time.sleep(0.01)
+                if timeout > 0:
+                    if start + time.monotonic() > timeout:
+                        return False
+        return True
+
+    def release(self):
+        '''Check if data read while locked is valid'''
+        if self.stats.in_progress or self.stats.epoch != self.epoch:
+            raise IOError('Optimistic lock failed, retry')
+
+    def locked(self):
+        '''Not used'''
+
+
+class StatsCombinedList(list):
+    '''Column slicing for Combined counters list'''
+
+    def __getitem__(self, item):
+        '''Supports partial numpy style 2d support. Slice by column [:,1]'''
+        if isinstance(item, int):
+            return list.__getitem__(self, item)
+        return CombinedList([row[item[1]] for row in self])
+
+class CombinedList(list):
+    '''Combined Counters 2-dimensional by thread by index of packets/octets'''
+
+    def packets(self):
+        '''Return column (2nd dimension). Packets for all threads'''
+        return [pair[0] for pair in self]
+
+    def octets(self):
+        '''Return column (2nd dimension). Octets for all threads'''
+        return [pair[1] for pair in self]
+
+    def sum_packets(self):
+        '''Return column (2nd dimension). Sum of all packets for all threads'''
+        return sum(self.packets())
+
+    def sum_octets(self):
+        '''Return column (2nd dimension). Sum of all octets for all threads'''
+        return sum(self.octets())
+
+class StatsTuple(tuple):
+    '''A Combined vector tuple (packets, octets)'''
+    def __init__(self, data):
+        self.dictionary = {'packets': data[0], 'bytes': data[1]}
+        super().__init__()
+
+    def __repr__(self):
+        return dict.__repr__(self.dictionary)
+
+    def __getitem__(self, item):
+        if isinstance(item, int):
+            return tuple.__getitem__(self, item)
+        if item == 'packets':
+            return tuple.__getitem__(self, 0)
+        return tuple.__getitem__(self, 1)
+
+class StatsSimpleList(list):
+    '''Simple Counters 2-dimensional by thread by index of packets'''
+
+    def __getitem__(self, item):
+        '''Supports partial numpy style 2d support. Slice by column [:,1]'''
+        if isinstance(item, int):
+            return list.__getitem__(self, item)
+        return SimpleList([row[item[1]] for row in self])
+
+class SimpleList(list):
+    '''Simple counter'''
+
+    def sum(self):
+        '''Sum the vector'''
+        return sum(self)
+
+class StatsEntry():
+    '''An individual stats entry'''
+    # pylint: disable=unused-argument,no-self-use
+
+    def __init__(self, stattype, statvalue):
+        self.type = stattype
+        self.value = statvalue
+
+        if stattype == 1:
+            self.function = self.scalar
+        elif stattype == 2:
+            self.function = self.simple
+        elif stattype == 3:
+            self.function = self.combined
+        elif stattype == 4:
+            self.function = self.error
+        elif stattype == 5:
+            self.function = self.name
+        elif stattype == 7:
+            self.function = self.symlink
+        else:
+            self.function = self.illegal
+
+    def illegal(self, stats):
+        '''Invalid or unknown counter type'''
+        return None
+
+    def scalar(self, stats):
+        '''Scalar counter'''
+        return self.value
+
+    def simple(self, stats):
+        '''Simple counter'''
+        counter = StatsSimpleList()
+        for threads in StatsVector(stats, self.value, 'P'):
+            clist = [v[0] for v in StatsVector(stats, threads[0], 'Q')]
+            counter.append(clist)
+        return counter
+
+    def combined(self, stats):
+        '''Combined counter'''
+        counter = StatsCombinedList()
+        for threads in StatsVector(stats, self.value, 'P'):
+            clist = [StatsTuple(cnt) for cnt in StatsVector(stats, threads[0], 'QQ')]
+            counter.append(clist)
+        return counter
+
+    def error(self, stats):
+        '''Error counter'''
+        counter = SimpleList()
+        for clist in stats.error_vectors:
+            counter.append(clist[self.value])
+        return counter
+
+    def name(self, stats):
+        '''Name counter'''
+        counter = []
+        for name in StatsVector(stats, self.value, 'P'):
+            if name[0]:
+                counter.append(get_string(stats, name[0]))
+        return counter
+
+    SYMLINK_FMT1 = Struct('II')
+    SYMLINK_FMT2 = Struct('Q')
+    def symlink(self, stats):
+        '''Symlink counter'''
+        b = self.SYMLINK_FMT2.pack(self.value)
+        index1, index2 = self.SYMLINK_FMT1.unpack(b)
+        name = stats.directory_by_idx[index1]
+        return stats[name][:,index2]
+
+    def get_counter(self, stats):
+        '''Return a list of counters'''
+        if stats:
+            return self.function(stats)
+
+class TestStats(unittest.TestCase):
+    '''Basic statseg tests'''
+
+    def setUp(self):
+        '''Connect to statseg'''
+        self.stat = VPPStats()
+        self.stat.connect()
+        self.profile = cProfile.Profile()
+        self.profile.enable()
+
+    def tearDown(self):
+        '''Disconnect from statseg'''
+        self.stat.disconnect()
+        profile = Stats(self.profile)
+        profile.strip_dirs()
+        profile.sort_stats('cumtime')
+        profile.print_stats()
+        print("\n--->>>")
+
+    def test_counters(self):
+        '''Test access to statseg'''
+
+        print('/err/abf-input-ip4/missed', self.stat['/err/abf-input-ip4/missed'])
+        print('/sys/heartbeat', self.stat['/sys/heartbeat'])
+        print('/if/names', self.stat['/if/names'])
+        print('/if/rx-miss', self.stat['/if/rx-miss'])
+        print('/if/rx-miss', self.stat['/if/rx-miss'][1])
+        print('/nat44-ed/out2in/slowpath/drops', self.stat['/nat44-ed/out2in/slowpath/drops'])
+        print('Set Errors', self.stat.set_errors())
+        with self.assertRaises(KeyError):
+            print('NO SUCH COUNTER', self.stat['foobar'])
+        print('/if/rx', self.stat.get_counter('/if/rx'))
+        print('/err/ethernet-input/no error',
+              self.stat.get_err_counter('/err/ethernet-input/no error'))
+
+    def test_column(self):
+        '''Test column slicing'''
+
+        print('/if/rx-miss', self.stat['/if/rx-miss'])
+        print('/if/rx', self.stat['/if/rx'])  # All interfaces for thread #1
+        print('/if/rx thread #1', self.stat['/if/rx'][0])  # All interfaces for thread #1
+        print('/if/rx thread #1, interface #1',
+              self.stat['/if/rx'][0][1])  # All interfaces for thread #1
+        print('/if/rx if_index #1', self.stat['/if/rx'][:, 1])
+        print('/if/rx if_index #1 packets', self.stat['/if/rx'][:, 1].packets())
+        print('/if/rx if_index #1 packets', self.stat['/if/rx'][:, 1].sum_packets())
+        print('/if/rx if_index #1 packets', self.stat['/if/rx'][:, 1].octets())
+        print('/if/rx-miss', self.stat['/if/rx-miss'])
+        print('/if/rx-miss if_index #1 packets', self.stat['/if/rx-miss'][:, 1].sum())
+        print('/if/rx if_index #1 packets', self.stat['/if/rx'][0][1]['packets'])
+
+    def test_error(self):
+        '''Test the error vector'''
+
+        print('/err/ethernet-input', self.stat['/err/ethernet-input/no error'])
+        print('/err/nat44-ei-ha/pkts-processed', self.stat['/err/nat44-ei-ha/pkts-processed'])
+        print('/err/ethernet-input', self.stat.get_err_counter('/err/ethernet-input/no error'))
+        print('/err/ethernet-input', self.stat['/err/ethernet-input/no error'].sum())
+
+    def test_nat44(self):
+        '''Test the nat counters'''
+
+        print('/nat44-ei/ha/del-event-recv', self.stat['/nat44-ei/ha/del-event-recv'])
+        print('/err/nat44-ei-ha/pkts-processed', self.stat['/err/nat44-ei-ha/pkts-processed'].sum())
+
+    def test_legacy(self):
+        '''Legacy interface'''
+        directory = self.stat.ls(["^/if", "/err/ip4-input", "/sys/node/ip4-input"])
+        data = self.stat.dump(directory)
+        print(data)
+        print('Looking up sys node')
+        directory = self.stat.ls(["^/sys/node"])
+        print('Dumping sys node')
+        data = self.stat.dump(directory)
+        print(data)
+        directory = self.stat.ls(["^/foobar"])
+        data = self.stat.dump(directory)
+        print(data)
+
+    def test_sys_nodes(self):
+        '''Test /sys/nodes'''
+        counters = self.stat.ls('^/sys/node')
+        print('COUNTERS:', counters)
+        print('/sys/node', self.stat.dump(counters))
+        print('/net/route/to', self.stat['/net/route/to'])
+
+    def test_symlink(self):
+        '''Symbolic links'''
+        print('/interface/local0/rx', self.stat['/interfaces/local0/rx'])
+        print('/sys/nodes/unix-epoll-input', self.stat['/nodes/unix-epoll-input/calls'])
+
+if __name__ == '__main__':
+    import cProfile
+    from pstats import Stats
+
+    unittest.main()
diff --git a/src/vpp/CMakeLists.txt b/src/vpp/CMakeLists.txt
index df8383709..6522e1175 100644
--- a/src/vpp/CMakeLists.txt
+++ b/src/vpp/CMakeLists.txt
@@ -61,6 +61,7 @@ set(VPP_SOURCES
   app/vpe_cli.c
   app/version.c
   stats/stat_segment.c
+  stats/stat_segment_provider.c
   api/api.c
   api/json_format.c
   api/custom_dump.c
diff --git a/src/vpp/stats/stat_segment.c b/src/vpp/stats/stat_segment.c
index 43a48707f..404edc588 100644
--- a/src/vpp/stats/stat_segment.c
+++ b/src/vpp/stats/stat_segment.c
@@ -230,6 +230,80 @@ vlib_stats_pop_heap (void *cm_arg, void *oldheap, u32 cindex,
   clib_mem_set_heap (oldheap);
 }
 
+u8 *
+format_vlib_stats_symlink (u8 * s, va_list * args)
+{
+  char *input = va_arg (*args, char *);
+  char *modified_input = vec_dup (input);
+  int i;
+  u8 *result;
+
+  for (i = 0; i < strlen (modified_input); i++)
+    if (modified_input[i] == '/')
+      modified_input[i] = '_';
+
+  result = format (s, "%s", modified_input);
+  vec_free (modified_input);
+  return result;
+}
+
+void
+vlib_stats_register_symlink (void *oldheap, u8 * name, u32 index1, u32 index2,
+			     u8 lock)
+{
+  stat_segment_main_t *sm = &stat_segment_main;
+  stat_segment_shared_header_t *shared_header = sm->shared_header;
+  stat_segment_directory_entry_t e;
+
+  ASSERT (shared_header);
+
+  if (lock)
+    vlib_stat_segment_lock ();
+  clib_mem_set_heap (oldheap);	/* Exit stats segment */
+  u32 vector_index = lookup_hash_index (name);
+  /* Back to stats segment */
+  clib_mem_set_heap (sm->heap);	/* Re-enter stat segment */
+
+  if (vector_index == STAT_SEGMENT_INDEX_INVALID)
+    {
+      memcpy (e.name, name, vec_len (name));
+      e.name[vec_len (name)] = '\0';
+      e.type = STAT_DIR_TYPE_SYMLINK;
+      e.index1 = index1;
+      e.index2 = index2;
+      vector_index = vlib_stats_create_counter (&e, oldheap);
+
+      /* Warn clients to refresh any pointers they might be holding */
+      shared_header->directory_vector = sm->directory_vector;
+    }
+
+  if (lock)
+    vlib_stat_segment_unlock ();
+}
+
+void
+vlib_stats_rename_symlink (void *oldheap, u64 index, u8 * new_name)
+{
+  stat_segment_main_t *sm = &stat_segment_main;
+  stat_segment_directory_entry_t *e;
+
+  ASSERT (clib_mem_get_heap () == sm->heap);
+
+  if (index > vec_len (sm->directory_vector))
+    return;
+
+  e = &sm->directory_vector[index];
+
+  clib_mem_set_heap (oldheap);
+  hash_unset (sm->directory_vector_by_name, &e->name);
+  clib_mem_set_heap (sm->heap);
+
+  strncpy (e->name, (char *) new_name, 128 - 1);
+  clib_mem_set_heap (oldheap);
+  hash_set (sm->directory_vector_by_name, &e->name, index);
+  clib_mem_set_heap (sm->heap);
+}
+
 void
 vlib_stats_register_error_index (void *oldheap, u8 * name, u64 * em_vec,
 				 u64 index)
@@ -261,21 +335,32 @@ vlib_stats_register_error_index (void *oldheap, u8 * name, u64 * em_vec,
   vlib_stat_segment_unlock ();
 }
 
+/*
+ * Creates a two dimensional vector with the maximum valid index specified in
+ * both dimensions as arguments.
+ * Must be called on the stat segment heap.
+ */
 static void
-stat_validate_counter_vector (stat_segment_directory_entry_t * ep, u32 max)
+stat_validate_counter_vector2 (stat_segment_directory_entry_t * ep, u32 max1,
+			       u32 max2)
 {
   counter_t **counters = ep->data;
-  vlib_thread_main_t *tm = vlib_get_thread_main ();
   int i;
-
-  vec_validate_aligned (counters, tm->n_vlib_mains - 1,
-			CLIB_CACHE_LINE_BYTES);
-  for (i = 0; i < tm->n_vlib_mains; i++)
-    vec_validate_aligned (counters[i], max, CLIB_CACHE_LINE_BYTES);
+  vec_validate_aligned (counters, max1, CLIB_CACHE_LINE_BYTES);
+  for (i = 0; i <= max1; i++)
+    vec_validate_aligned (counters[i], max2, CLIB_CACHE_LINE_BYTES);
 
   ep->data = counters;
 }
 
+static void
+stat_validate_counter_vector (stat_segment_directory_entry_t * ep, u32 max)
+{
+  vlib_thread_main_t *tm = vlib_get_thread_main ();
+  ASSERT (tm->n_vlib_mains > 0);
+  stat_validate_counter_vector2 (ep, tm->n_vlib_mains, max);
+}
+
 always_inline void
 stat_set_simple_counter (stat_segment_directory_entry_t * ep,
 			 u32 thread_index, u32 index, u64 value)
@@ -310,6 +395,41 @@ vlib_stats_pop_heap2 (u64 * error_vector, u32 thread_index, void *oldheap,
   clib_mem_set_heap (oldheap);
 }
 
+/*
+ * Create a new entry and add name to directory hash.
+ * Returns ~0 if name exists.
+ * Called from main heap.
+ */
+u32
+stat_segment_new_entry (u8 * name, stat_directory_type_t t)
+{
+  stat_segment_main_t *sm = &stat_segment_main;
+  stat_segment_shared_header_t *shared_header = sm->shared_header;
+  void *oldheap;
+  stat_segment_directory_entry_t e;
+
+  ASSERT (shared_header);
+
+  u32 vector_index = lookup_hash_index (name);
+  if (vector_index != STAT_SEGMENT_INDEX_INVALID)	/* Already registered */
+    return ~0;
+
+  memset (&e, 0, sizeof (e));
+  e.type = t;
+  memcpy (e.name, name, vec_len (name));
+
+  oldheap = vlib_stats_push_heap (NULL);
+  vlib_stat_segment_lock ();
+  vector_index = vlib_stats_create_counter (&e, oldheap);
+
+  shared_header->directory_vector = sm->directory_vector;
+
+  vlib_stat_segment_unlock ();
+  clib_mem_set_heap (oldheap);
+
+  return vector_index;
+}
+
 clib_error_t *
 vlib_map_stat_segment_init (void)
 {
@@ -344,9 +464,10 @@ vlib_map_stat_segment_init (void)
 
   sys_page_sz = clib_mem_get_page_size ();
 
-  heap = clib_mem_create_heap (((u8 *) memaddr) + sys_page_sz, memory_size
-			       - sys_page_sz, 1 /* locked */ ,
-			       "stat segment");
+  heap =
+    clib_mem_create_heap (((u8 *) memaddr) + sys_page_sz,
+			  memory_size - sys_page_sz, 1 /* locked */ ,
+			  mem_name);
   sm->heap = heap;
   sm->memfd = mfd;
 
@@ -378,11 +499,7 @@ vlib_map_stat_segment_init (void)
 
   clib_mem_set_heap (oldheap);
 
-  /* Total shared memory size */
-  clib_mem_usage_t usage;
-  clib_mem_get_heap_usage (sm->heap, &usage);
-  sm->directory_vector[STAT_COUNTER_MEM_STATSEG_TOTAL].value =
-    usage.bytes_total;
+  vlib_stats_register_mem_heap (heap);
 
   return 0;
 }
@@ -429,6 +546,10 @@ format_stat_dir_entry (u8 * s, va_list * args)
       type_name = "empty";
       break;
 
+    case STAT_DIR_TYPE_SYMLINK:
+      type_name = "Symlink";
+      break;
+
     default:
       type_name = "illegal!";
       break;
@@ -507,12 +628,11 @@ update_node_counters (stat_segment_main_t * sm)
   static u32 no_max_nodes = 0;
 
   vlib_node_get_nodes (0 /* vm, for barrier sync */ ,
-		       (u32) ~ 0 /* all threads */ ,
-		       1 /* include stats */ ,
-		       0 /* barrier sync */ ,
-		       &node_dups, &stat_vms);
+		       (u32) ~ 0 /* all threads */ , 1 /* include stats */ ,
+		       0 /* barrier sync */ , &node_dups, &stat_vms);
 
   u32 l = vec_len (node_dups[0]);
+  u8 *symlink_name = 0;
 
   /*
    * Extend performance nodes if necessary
@@ -547,7 +667,17 @@ update_node_counters (stat_segment_main_t * sm)
 	  if (sm->nodes[n->index])
 	    vec_free (sm->nodes[n->index]);
 	  sm->nodes[n->index] = s;
+
+#define _(E, t, name, p)                                                      \
+  vec_reset_length (symlink_name);                                            \
+  symlink_name = format (symlink_name, "/nodes/%U/" #name "%c",               \
+			 format_vlib_stats_symlink, s, 0);                    \
+  vlib_stats_register_symlink (oldheap, symlink_name, STAT_COUNTER_##E,       \
+			       n->index, 0 /* don't lock */);
+	  foreach_stat_segment_node_counter_name
+#undef _
 	}
+      vec_free (symlink_name);
       vlib_stat_segment_unlock ();
       clib_mem_set_heap (oldheap);
       no_max_nodes = l;
@@ -563,6 +693,39 @@ update_node_counters (stat_segment_main_t * sm)
 	  counter_t *c;
 	  vlib_node_t *n = nodes[i];
 
+	  if (j == 0)
+	    {
+	      if (strncmp ((char *) sm->nodes[n->index], (char *) n->name,
+			   strlen ((char *) sm->nodes[n->index])))
+		{
+		  u8 *s = 0;
+		  u32 vector_index;
+		  u8 *symlink_new_name = 0;
+		  void *oldheap = clib_mem_set_heap (sm->heap);
+		  vlib_stat_segment_lock ();
+		  s = format (s, "%v%c", n->name, 0);
+#define _(E, t, name, p)                                                      \
+  vec_reset_length (symlink_name);                                            \
+  symlink_name = format (symlink_name, "/nodes/%U/" #name "%c",               \
+			 format_vlib_stats_symlink, sm->nodes[n->index], 0);  \
+  clib_mem_set_heap (oldheap); /* Exit stats segment */                       \
+  vector_index = lookup_hash_index ((u8 *) symlink_name);                     \
+  clib_mem_set_heap (sm->heap); /* Re-enter stat segment */                   \
+  vec_reset_length (symlink_new_name);                                        \
+  symlink_new_name = format (symlink_new_name, "/nodes/%U/" #name "%c",       \
+			     format_vlib_stats_symlink, s, 0);                \
+  vlib_stats_rename_symlink (oldheap, vector_index, symlink_new_name);
+		  foreach_stat_segment_node_counter_name
+#undef _
+		    vec_free (symlink_name);
+		  vec_free (symlink_new_name);
+		  vec_free (sm->nodes[n->index]);
+		  sm->nodes[n->index] = s;
+		  vlib_stat_segment_unlock ();
+		  clib_mem_set_heap (oldheap);
+		}
+	    }
+
 	  counters = sm->directory_vector[STAT_COUNTER_NODE_CLOCKS].data;
 	  c = counters[j];
 	  c[n->index] = n->stats_total.clocks - n->stats_last_clear.clocks;
@@ -656,12 +819,6 @@ do_stat_segment_updates (stat_segment_main_t * sm)
   sm->directory_vector[STAT_COUNTER_LAST_STATS_CLEAR].value =
     vm->node_main.time_last_runtime_stats_clear;
 
-  /* Stats segment memory heap counter */
-  clib_mem_usage_t usage;
-  clib_mem_get_heap_usage (sm->heap, &usage);
-  sm->directory_vector[STAT_COUNTER_MEM_STATSEG_USED].value =
-    usage.bytes_used;
-
   if (sm->node_counters_enabled)
     update_node_counters (sm);
 
@@ -764,56 +921,41 @@ stat_segment_collector_process (vlib_main_t * vm, vlib_node_runtime_t * rt,
   return 0;			/* or not */
 }
 
-static clib_error_t *
-statseg_init (vlib_main_t * vm)
+/*
+ * Add a data provider (via callback) for a given stats entry.
+ * TODO: Add support for per-provider interval.
+ */
+void
+stat_segment_poll_add (u32 vector_index, stat_segment_update_fn update_fn,
+		       u32 caller_index, u32 interval)
 {
   stat_segment_main_t *sm = &stat_segment_main;
+  stat_segment_gauges_pool_t *gauge;
 
-  /* set default socket file name when statseg config stanza is empty. */
-  if (!vec_len (sm->socket_name))
-    sm->socket_name = format (0, "%s/%s%c", vlib_unix_get_runtime_dir (),
-			      STAT_SEGMENT_SOCKET_FILENAME, 0);
-  return stats_segment_socket_init ();
-}
+  pool_get (sm->gauges, gauge);
+  gauge->fn = update_fn;
+  gauge->caller_index = caller_index;
+  gauge->directory_index = vector_index;
 
-/* *INDENT-OFF* */
-VLIB_INIT_FUNCTION (statseg_init) =
-{
-  .runs_after = VLIB_INITS("unix_input_init"),
-};
-/* *INDENT-ON* */
+  return;
+}
 
+/*
+ * Create an scalar entry with a data provider.
+ * Deprecated, replace with stat_segment_new_entry + stat_segment_pool_add
+ */
 clib_error_t *
 stat_segment_register_gauge (u8 * name, stat_segment_update_fn update_fn,
 			     u32 caller_index)
 {
   stat_segment_main_t *sm = &stat_segment_main;
-  stat_segment_shared_header_t *shared_header = sm->shared_header;
-  void *oldheap;
-  stat_segment_directory_entry_t e;
   stat_segment_gauges_pool_t *gauge;
 
-  ASSERT (shared_header);
-
-  u32 vector_index = lookup_hash_index (name);
-
-  if (vector_index != STAT_SEGMENT_INDEX_INVALID)	/* Already registered */
+  u32 vector_index =
+    stat_segment_new_entry (name, STAT_DIR_TYPE_SCALAR_INDEX);
+  if (vector_index == ~0)	/* Already registered */
     return clib_error_return (0, "%v is already registered", name);
 
-  memset (&e, 0, sizeof (e));
-  e.type = STAT_DIR_TYPE_SCALAR_INDEX;
-  memcpy (e.name, name, vec_len (name));
-
-  oldheap = vlib_stats_push_heap (NULL);
-  vlib_stat_segment_lock ();
-  vector_index = vlib_stats_create_counter (&e, oldheap);
-
-  shared_header->directory_vector = sm->directory_vector;
-
-  vlib_stat_segment_unlock ();
-  clib_mem_set_heap (oldheap);
-
-  /* Back on our own heap */
   pool_get (sm->gauges, gauge);
   gauge->fn = update_fn;
   gauge->caller_index = caller_index;
@@ -825,33 +967,12 @@ stat_segment_register_gauge (u8 * name, stat_segment_update_fn update_fn,
 clib_error_t *
 stat_segment_register_state_counter (u8 * name, u32 * index)
 {
-  stat_segment_main_t *sm = &stat_segment_main;
-  stat_segment_shared_header_t *shared_header = sm->shared_header;
-  void *oldheap;
-  stat_segment_directory_entry_t e;
-
-  ASSERT (shared_header);
   ASSERT (vlib_get_thread_index () == 0);
 
-  u32 vector_index = lookup_hash_index (name);
-
-  if (vector_index != STAT_SEGMENT_INDEX_INVALID)	/* Already registered */
+  u32 vector_index =
+    stat_segment_new_entry (name, STAT_DIR_TYPE_SCALAR_INDEX);
+  if (vector_index == ~0)	/* Already registered */
     return clib_error_return (0, "%v is already registered", name);
-
-  memset (&e, 0, sizeof (e));
-  e.type = STAT_DIR_TYPE_SCALAR_INDEX;
-  memcpy (e.name, name, vec_len (name));
-
-  oldheap = vlib_stats_push_heap (NULL);
-  vlib_stat_segment_lock ();
-
-  vector_index = vlib_stats_create_counter (&e, oldheap);
-
-  shared_header->directory_vector = sm->directory_vector;
-
-  vlib_stat_segment_unlock ();
-  clib_mem_set_heap (oldheap);
-
   *index = vector_index;
   return 0;
 }
@@ -939,32 +1060,60 @@ static clib_error_t *
 statseg_sw_interface_add_del (vnet_main_t * vnm, u32 sw_if_index, u32 is_add)
 {
   stat_segment_main_t *sm = &stat_segment_main;
+  vnet_sw_interface_t *si = vnet_get_sw_interface (vnm, sw_if_index);
+  vnet_sw_interface_t *si_sup =
+    vnet_get_sup_sw_interface (vnm, si->sw_if_index);
+  vnet_hw_interface_t *hi_sup;
+  u8 *s = 0;
+  u8 *symlink_name = 0;
+  u32 vector_index;
 
   void *oldheap = vlib_stats_push_heap (sm->interfaces);
   vlib_stat_segment_lock ();
 
   vec_validate (sm->interfaces, sw_if_index);
+
+  ASSERT (si_sup->type == VNET_SW_INTERFACE_TYPE_HARDWARE);
+  hi_sup = vnet_get_hw_interface (vnm, si_sup->hw_if_index);
+
+  s = format (s, "%v", hi_sup->name);
+  if (si->type != VNET_SW_INTERFACE_TYPE_HARDWARE)
+    s = format (s, ".%d", si->sub.id);
+  s = format (s, "%c", 0);
+
   if (is_add)
     {
-      vnet_sw_interface_t *si = vnet_get_sw_interface (vnm, sw_if_index);
-      vnet_sw_interface_t *si_sup =
-	vnet_get_sup_sw_interface (vnm, si->sw_if_index);
-      vnet_hw_interface_t *hi_sup;
-
-      ASSERT (si_sup->type == VNET_SW_INTERFACE_TYPE_HARDWARE);
-      hi_sup = vnet_get_hw_interface (vnm, si_sup->hw_if_index);
-
-      u8 *s = 0;
-      s = format (s, "%v", hi_sup->name);
-      if (si->type != VNET_SW_INTERFACE_TYPE_HARDWARE)
-	s = format (s, ".%d", si->sub.id);
-      s = format (s, "%c", 0);
       sm->interfaces[sw_if_index] = s;
+#define _(E, n, p)                                                            \
+  clib_mem_set_heap (oldheap); /* Exit stats segment */                       \
+  vector_index = lookup_hash_index ((u8 *) "/" #p "/" #n);                    \
+  clib_mem_set_heap (sm->heap); /* Re-enter stat segment */                   \
+  vec_reset_length (symlink_name);                                            \
+  symlink_name = format (symlink_name, "/interfaces/%U/" #n "%c",             \
+			 format_vlib_stats_symlink, s, 0);                    \
+  vlib_stats_register_symlink (oldheap, symlink_name, vector_index,           \
+			       sw_if_index, 0 /* don't lock */);
+      foreach_simple_interface_counter_name
+	foreach_combined_interface_counter_name
+#undef _
+	vec_free (symlink_name);
     }
   else
     {
       vec_free (sm->interfaces[sw_if_index]);
       sm->interfaces[sw_if_index] = 0;
+#define _(E, n, p)                                                            \
+  vec_reset_length (symlink_name);                                            \
+  symlink_name = format (symlink_name, "/interfaces/%U/" #n "%c",             \
+			 format_vlib_stats_symlink, s, 0);                    \
+  clib_mem_set_heap (oldheap); /* Exit stats segment */                       \
+  vector_index = lookup_hash_index ((u8 *) symlink_name);                     \
+  clib_mem_set_heap (sm->heap); /* Re-enter stat segment */                   \
+  vlib_stats_delete_counter (vector_index, oldheap);
+      foreach_simple_interface_counter_name
+	foreach_combined_interface_counter_name
+#undef _
+	vec_free (symlink_name);
     }
 
   stat_segment_directory_entry_t *ep;
@@ -979,15 +1128,27 @@ statseg_sw_interface_add_del (vnet_main_t * vnm, u32 sw_if_index, u32 is_add)
 
 VNET_SW_INTERFACE_ADD_DEL_FUNCTION (statseg_sw_interface_add_del);
 
-/* *INDENT-OFF* */
-VLIB_REGISTER_NODE (stat_segment_collector, static) =
-{
-.function = stat_segment_collector_process,
-.name = "statseg-collector-process",
-.type = VLIB_NODE_TYPE_PROCESS,
+VLIB_REGISTER_NODE (stat_segment_collector, static) = {
+  .function = stat_segment_collector_process,
+  .name = "statseg-collector-process",
+  .type = VLIB_NODE_TYPE_PROCESS,
 };
 
-/* *INDENT-ON* */
+static clib_error_t *
+statseg_init (vlib_main_t * vm)
+{
+  stat_segment_main_t *sm = &stat_segment_main;
+
+  /* set default socket file name when statseg config stanza is empty. */
+  if (!vec_len (sm->socket_name))
+    sm->socket_name = format (0, "%s/%s%c", vlib_unix_get_runtime_dir (),
+			      STAT_SEGMENT_SOCKET_FILENAME, 0);
+  return stats_segment_socket_init ();
+}
+
+VLIB_INIT_FUNCTION (statseg_init) = {
+  .runs_after = VLIB_INITS ("unix_input_init"),
+};
 
 /*
  * fd.io coding-style-patch-verification: ON
diff --git a/src/vpp/stats/stat_segment.h b/src/vpp/stats/stat_segment.h
index a048fa5b8..c6056b1fa 100644
--- a/src/vpp/stats/stat_segment.h
+++ b/src/vpp/stats/stat_segment.h
@@ -35,28 +35,29 @@ typedef enum
  STAT_COUNTER_NODE_SUSPENDS,
  STAT_COUNTER_INTERFACE_NAMES,
  STAT_COUNTER_NODE_NAMES,
- STAT_COUNTER_MEM_STATSEG_TOTAL,
- STAT_COUNTER_MEM_STATSEG_USED,
  STAT_COUNTERS
 } stat_segment_counter_t;
 
-#define foreach_stat_segment_counter_name                       \
-  _(VECTOR_RATE, SCALAR_INDEX, vector_rate, /sys)               \
-  _(VECTOR_RATE_PER_WORKER, COUNTER_VECTOR_SIMPLE,              \
-    vector_rate_per_worker, /sys)                               \
-  _(NUM_WORKER_THREADS, SCALAR_INDEX, num_worker_threads, /sys) \
-  _(INPUT_RATE, SCALAR_INDEX, input_rate, /sys)                 \
-  _(LAST_UPDATE, SCALAR_INDEX, last_update, /sys)               \
-  _(LAST_STATS_CLEAR, SCALAR_INDEX, last_stats_clear, /sys)     \
-  _(HEARTBEAT, SCALAR_INDEX, heartbeat, /sys)                   \
-  _(NODE_CLOCKS, COUNTER_VECTOR_SIMPLE, clocks, /sys/node)      \
-  _(NODE_VECTORS, COUNTER_VECTOR_SIMPLE, vectors, /sys/node)    \
-  _(NODE_CALLS, COUNTER_VECTOR_SIMPLE, calls, /sys/node)        \
-  _(NODE_SUSPENDS, COUNTER_VECTOR_SIMPLE, suspends, /sys/node)  \
-  _(INTERFACE_NAMES, NAME_VECTOR, names, /if)                   \
-  _(NODE_NAMES, NAME_VECTOR, names, /sys/node)                  \
-  _(MEM_STATSEG_TOTAL, SCALAR_INDEX, total, /mem/statseg)       \
-  _(MEM_STATSEG_USED, SCALAR_INDEX, used, /mem/statseg)
+/* clang-format off */
+#define foreach_stat_segment_node_counter_name                                \
+  _ (NODE_CLOCKS, COUNTER_VECTOR_SIMPLE, clocks, /sys/node)                   \
+  _ (NODE_VECTORS, COUNTER_VECTOR_SIMPLE, vectors, /sys/node)                 \
+  _ (NODE_CALLS, COUNTER_VECTOR_SIMPLE, calls, /sys/node)                     \
+  _ (NODE_SUSPENDS, COUNTER_VECTOR_SIMPLE, suspends, /sys/node)
+
+#define foreach_stat_segment_counter_name                                     \
+  _ (VECTOR_RATE, SCALAR_INDEX, vector_rate, /sys)                            \
+  _ (VECTOR_RATE_PER_WORKER, COUNTER_VECTOR_SIMPLE, vector_rate_per_worker,   \
+     /sys)                                                                    \
+  _ (NUM_WORKER_THREADS, SCALAR_INDEX, num_worker_threads, /sys)              \
+  _ (INPUT_RATE, SCALAR_INDEX, input_rate, /sys)                              \
+  _ (LAST_UPDATE, SCALAR_INDEX, last_update, /sys)                            \
+  _ (LAST_STATS_CLEAR, SCALAR_INDEX, last_stats_clear, /sys)                  \
+  _ (HEARTBEAT, SCALAR_INDEX, heartbeat, /sys)                                \
+  _ (INTERFACE_NAMES, NAME_VECTOR, names, /if)                                \
+  _ (NODE_NAMES, NAME_VECTOR, names, /sys/node)                               \
+  foreach_stat_segment_node_counter_name
+/* clang-format on */
 
 /* Default stat segment 32m */
 #define STAT_SEGMENT_DEFAULT_SIZE	(32<<20)
@@ -112,5 +113,14 @@ stat_segment_register_state_counter(u8 *name, u32 *index);
 clib_error_t *
 stat_segment_deregister_state_counter(u32 index);
 void stat_segment_set_state_counter (u32 index, u64 value);
+void stat_segment_poll_add (u32 vector_index, stat_segment_update_fn update_fn,
+			    u32 caller_index, u32 interval);
+
+u32 stat_segment_new_entry (u8 *name, stat_directory_type_t t);
+void vlib_stats_register_mem_heap (clib_mem_heap_t *heap);
+void vlib_stat_segment_lock (void);
+void vlib_stat_segment_unlock (void);
+void vlib_stats_register_symlink (void *oldheap, u8 *name, u32 index1,
+				  u32 index2, u8 lock);
 
 #endif
diff --git a/src/vpp/stats/stat_segment_provider.c b/src/vpp/stats/stat_segment_provider.c
new file mode 100644
index 000000000..2212ffe98
--- /dev/null
+++ b/src/vpp/stats/stat_segment_provider.c
@@ -0,0 +1,121 @@
+/*
+ * Copyright (c) 2021 Cisco and/or its affiliates.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Counters handled by the stats module directly.
+ */
+
+#include <stdbool.h>
+#include <vppinfra/mem.h>
+#include <vppinfra/vec.h>
+#include <vlib/vlib.h>
+#include <vlib/counter.h>
+#include "stat_segment.h"
+
+clib_mem_heap_t **memory_heaps_vec;
+u32 mem_vector_index;
+bool initialized = false;
+
+enum
+{
+  STAT_MEM_TOTAL = 0,
+  STAT_MEM_USED,
+  STAT_MEM_FREE,
+  STAT_MEM_USED_MMAP,
+  STAT_MEM_TOTAL_ALLOC,
+  STAT_MEM_FREE_CHUNKS,
+  STAT_MEM_RELEASABLE,
+} stat_mem_usage_e;
+
+/*
+ * Called from the stats periodic process to update memory counters.
+ */
+static void
+stat_provider_mem_usage_update_fn (stat_segment_directory_entry_t *e,
+				   u32 index)
+{
+  clib_mem_usage_t usage;
+  clib_mem_heap_t *heap;
+  counter_t **counters = e->data;
+  counter_t *cb;
+
+  heap = vec_elt (memory_heaps_vec, index);
+  clib_mem_get_heap_usage (heap, &usage);
+  cb = counters[0];
+  cb[STAT_MEM_TOTAL] = usage.bytes_total;
+  cb[STAT_MEM_USED] = usage.bytes_used;
+  cb[STAT_MEM_FREE] = usage.bytes_free;
+  cb[STAT_MEM_USED_MMAP] = usage.bytes_used_mmap;
+  cb[STAT_MEM_TOTAL_ALLOC] = usage.bytes_max;
+  cb[STAT_MEM_FREE_CHUNKS] = usage.bytes_free_reclaimed;
+  cb[STAT_MEM_RELEASABLE] = usage.bytes_overhead;
+}
+
+static counter_t **
+stat_validate_counter_vector3 (counter_t **counters, u32 max1, u32 max2)
+{
+  stat_segment_main_t *sm = &stat_segment_main;
+  int i;
+  void *oldheap = clib_mem_set_heap (sm->heap);
+  vec_validate_aligned (counters, max1, CLIB_CACHE_LINE_BYTES);
+  for (i = 0; i <= max1; i++)
+    vec_validate_aligned (counters[i], max2, CLIB_CACHE_LINE_BYTES);
+  clib_mem_set_heap (oldheap);
+  return counters;
+}
+
+/*
+ * Provide memory heap counters.
+ * Two dimensional array of heap index and per-heap gauges.
+ */
+void
+vlib_stats_register_mem_heap (clib_mem_heap_t *heap)
+{
+  stat_segment_main_t *sm = &stat_segment_main;
+  vec_add1 (memory_heaps_vec, heap);
+  u32 heap_index = vec_len (memory_heaps_vec) - 1;
+
+  /* Memory counters provider */
+  u8 *s = format (0, "/mem/%s", heap->name);
+  u8 *s_used = format (0, "/mem/%s/used", heap->name);
+  u8 *s_total = format (0, "/mem/%s/total", heap->name);
+  u8 *s_free = format (0, "/mem/%s/free", heap->name);
+  mem_vector_index =
+    stat_segment_new_entry (s, STAT_DIR_TYPE_COUNTER_VECTOR_SIMPLE);
+  vec_free (s);
+  if (mem_vector_index == ~0)
+    ASSERT (0);
+
+  vlib_stat_segment_lock ();
+  stat_segment_directory_entry_t *ep = &sm->directory_vector[mem_vector_index];
+  ep->data = stat_validate_counter_vector3 (ep->data, 0, STAT_MEM_RELEASABLE);
+
+  /* Create symlink */
+  void *oldheap = clib_mem_set_heap (sm->heap);
+  vlib_stats_register_symlink (oldheap, s_total, mem_vector_index,
+			       STAT_MEM_TOTAL, 0);
+  vlib_stats_register_symlink (oldheap, s_used, mem_vector_index,
+			       STAT_MEM_USED, 0);
+  vlib_stats_register_symlink (oldheap, s_free, mem_vector_index,
+			       STAT_MEM_FREE, 0);
+  vlib_stat_segment_unlock ();
+  clib_mem_set_heap (oldheap);
+  vec_free (s_used);
+  vec_free (s_total);
+  vec_free (s_free);
+
+  stat_segment_poll_add (mem_vector_index, stat_provider_mem_usage_update_fn,
+			 heap_index, 10);
+}
diff --git a/src/vpp/stats/stat_segment_shared.h b/src/vpp/stats/stat_segment_shared.h
index b09e2b561..6f26d4b9f 100644
--- a/src/vpp/stats/stat_segment_shared.h
+++ b/src/vpp/stats/stat_segment_shared.h
@@ -25,12 +25,18 @@ typedef enum
   STAT_DIR_TYPE_ERROR_INDEX,
   STAT_DIR_TYPE_NAME_VECTOR,
   STAT_DIR_TYPE_EMPTY,
+  STAT_DIR_TYPE_SYMLINK,
 } stat_directory_type_t;
 
 typedef struct
 {
   stat_directory_type_t type;
   union {
+    struct
+    {
+      uint32_t index1;
+      uint32_t index2;
+    };
     uint64_t index;
     uint64_t value;
     void *data;
diff --git a/src/vppinfra/mem_dlmalloc.c b/src/vppinfra/mem_dlmalloc.c
index bc6561a73..752dce348 100644
--- a/src/vppinfra/mem_dlmalloc.c
+++ b/src/vppinfra/mem_dlmalloc.c
@@ -474,14 +474,17 @@ clib_mem_get_heap_usage (clib_mem_heap_t * heap, clib_mem_usage_t * usage)
 {
   struct dlmallinfo mi = mspace_mallinfo (heap->mspace);
 
-  /* TODO: Fill in some more values */
+  usage->bytes_total = mi.arena;	/* non-mmapped space allocated from system */
+  usage->bytes_used = mi.uordblks;	/* total allocated space */
+  usage->bytes_free = mi.fordblks;	/* total free space */
+  usage->bytes_used_mmap = mi.hblkhd;	/* space in mmapped regions */
+  usage->bytes_max = mi.usmblks;	/* maximum total allocated space */
+  usage->bytes_free_reclaimed = mi.ordblks;	/* number of free chunks */
+  usage->bytes_overhead = mi.keepcost;	/* releasable (via malloc_trim) space */
+
+  /* Not supported */
+  usage->bytes_used_sbrk = 0;
   usage->object_count = 0;
-  usage->bytes_total = mi.arena;
-  usage->bytes_overhead = 0;
-  usage->bytes_max = 0;
-  usage->bytes_used = mi.uordblks;
-  usage->bytes_free = mi.fordblks;
-  usage->bytes_free_reclaimed = 0;
 }
 
 /* Call serial number for debugger breakpoints. */
diff --git a/test/framework.py b/test/framework.py
index f5775134d..ca884bb25 100644
--- a/test/framework.py
+++ b/test/framework.py
@@ -260,6 +260,7 @@ class VppTestCase(unittest.TestCase):
     classes. It provides methods to create and run test case.
     """
 
+    extra_vpp_statseg_config = ""
     extra_vpp_punt_config = []
     extra_vpp_plugin_config = []
     logger = null_logger
@@ -1123,7 +1124,7 @@ class VppTestCase(unittest.TestCase):
                           "packet counter `%s'" % counter)
 
     def assert_error_counter_equal(self, counter, expected_value):
-        counter_value = self.statistics.get_err_counter(counter)
+        counter_value = self.statistics[counter].sum()
         self.assert_equal(counter_value, expected_value,
                           "error counter `%s'" % counter)
 
diff --git a/test/template_ipsec.py b/test/template_ipsec.py
index 129f220c3..b569ba822 100644
--- a/test/template_ipsec.py
+++ b/test/template_ipsec.py
@@ -286,8 +286,9 @@ class IpsecTra4(object):
         p = self.params[socket.AF_INET]
         esn_en = p.vpp_tra_sa.esn_en
 
-        seq_cycle_node_name = ('/err/%s/sequence number cycled' %
-                               self.tra4_encrypt_node_name)
+        seq_cycle_node_name = \
+            ('/err/%s/sequence number cycled (packet dropped)' %
+             self.tra4_encrypt_node_name)
         replay_node_name = ('/err/%s/SA replayed packet' %
                             self.tra4_decrypt_node_name)
         if ESP == self.encryption_type and p.crypt_algo == "AES-GCM":
diff --git a/test/test_ipsec_tun_if_esp.py b/test/test_ipsec_tun_if_esp.py
index f505fa0eb..31860705e 100644
--- a/test/test_ipsec_tun_if_esp.py
+++ b/test/test_ipsec_tun_if_esp.py
@@ -394,10 +394,8 @@ class TestIpsec4MultiTunIfEsp(TemplateIpsec, IpsecTun4):
         """Multiple IPSEC tunnel interfaces """
         for p in self.multi_params:
             self.verify_tun_44(p, count=127)
-            c = p.tun_if.get_rx_stats()
-            self.assertEqual(c['packets'], 127)
-            c = p.tun_if.get_tx_stats()
-            self.assertEqual(c['packets'], 127)
+            self.assertEqual(p.tun_if.get_rx_stats(), 127)
+            self.assertEqual(p.tun_if.get_tx_stats(), 127)
 
     def test_tun_rr_44(self):
         """ Round-robin packets acrros multiple interface """
@@ -727,10 +725,8 @@ class TestIpsec6MultiTunIfEsp(TemplateIpsec, IpsecTun6):
         """Multiple IPSEC tunnel interfaces """
         for p in self.multi_params:
             self.verify_tun_66(p, count=127)
-            c = p.tun_if.get_rx_stats()
-            self.assertEqual(c['packets'], 127)
-            c = p.tun_if.get_tx_stats()
-            self.assertEqual(c['packets'], 127)
+            self.assertEqual(p.tun_if.get_rx_stats(), 127)
+            self.assertEqual(p.tun_if.get_tx_stats(), 127)
 
 
 class TestIpsecGreTebIfEsp(TemplateIpsec,
@@ -1878,17 +1874,13 @@ class TestIpsec4TunProtect(TemplateIpsec,
         self.config_protect(p)
 
         self.verify_tun_44(p, count=127)
-        c = p.tun_if.get_rx_stats()
-        self.assertEqual(c['packets'], 127)
-        c = p.tun_if.get_tx_stats()
-        self.assertEqual(c['packets'], 127)
+        self.assertEqual(p.tun_if.get_rx_stats(), 127)
+        self.assertEqual(p.tun_if.get_tx_stats(), 127)
 
         self.vapi.cli("clear ipsec sa")
         self.verify_tun_64(p, count=127)
-        c = p.tun_if.get_rx_stats()
-        self.assertEqual(c['packets'], 254)
-        c = p.tun_if.get_tx_stats()
-        self.assertEqual(c['packets'], 254)
+        self.assertEqual(p.tun_if.get_rx_stats(), 254)
+        self.assertEqual(p.tun_if.get_tx_stats(), 254)
 
         # rekey - create new SAs and update the tunnel protection
         np = copy.copy(p)
@@ -1905,10 +1897,8 @@ class TestIpsec4TunProtect(TemplateIpsec,
         self.unconfig_sa(p)
 
         self.verify_tun_44(np, count=127)
-        c = p.tun_if.get_rx_stats()
-        self.assertEqual(c['packets'], 381)
-        c = p.tun_if.get_tx_stats()
-        self.assertEqual(c['packets'], 381)
+        self.assertEqual(p.tun_if.get_rx_stats(), 381)
+        self.assertEqual(p.tun_if.get_tx_stats(), 381)
 
         # teardown
         self.unconfig_protect(np)
@@ -1954,10 +1944,8 @@ class TestIpsec4TunProtectUdp(TemplateIpsec,
         p = self.ipv4_params
 
         self.verify_tun_44(p, count=127)
-        c = p.tun_if.get_rx_stats()
-        self.assertEqual(c['packets'], 127)
-        c = p.tun_if.get_tx_stats()
-        self.assertEqual(c['packets'], 127)
+        self.assertEqual(p.tun_if.get_rx_stats(), 127)
+        self.assertEqual(p.tun_if.get_tx_stats(), 127)
 
     def test_keepalive(self):
         """ IPSEC NAT Keepalive """
@@ -2047,10 +2035,8 @@ class TestIpsec4TunProtectTun(TemplateIpsec,
 
         self.verify_tun_44(p, count=127)
 
-        c = p.tun_if.get_rx_stats()
-        self.assertEqual(c['packets'], 127)
-        c = p.tun_if.get_tx_stats()
-        self.assertEqual(c['packets'], 127)
+        self.assertEqual(p.tun_if.get_rx_stats(), 127)
+        self.assertEqual(p.tun_if.get_tx_stats(), 127)
 
         # rekey - create new SAs and update the tunnel protection
         np = copy.copy(p)
@@ -2067,10 +2053,8 @@ class TestIpsec4TunProtectTun(TemplateIpsec,
         self.unconfig_sa(p)
 
         self.verify_tun_44(np, count=127)
-        c = p.tun_if.get_rx_stats()
-        self.assertEqual(c['packets'], 254)
-        c = p.tun_if.get_tx_stats()
-        self.assertEqual(c['packets'], 254)
+        self.assertEqual(p.tun_if.get_rx_stats(), 254)
+        self.assertEqual(p.tun_if.get_tx_stats(), 254)
 
         # teardown
         self.unconfig_protect(np)
@@ -2228,10 +2212,8 @@ class TestIpsec6TunProtect(TemplateIpsec,
         self.config_protect(p)
 
         self.verify_tun_66(p, count=127)
-        c = p.tun_if.get_rx_stats()
-        self.assertEqual(c['packets'], 127)
-        c = p.tun_if.get_tx_stats()
-        self.assertEqual(c['packets'], 127)
+        self.assertEqual(p.tun_if.get_rx_stats(), 127)
+        self.assertEqual(p.tun_if.get_tx_stats(), 127)
 
         # rekey - create new SAs and update the tunnel protection
         np = copy.copy(p)
@@ -2248,10 +2230,8 @@ class TestIpsec6TunProtect(TemplateIpsec,
         self.unconfig_sa(p)
 
         self.verify_tun_66(np, count=127)
-        c = p.tun_if.get_rx_stats()
-        self.assertEqual(c['packets'], 254)
-        c = p.tun_if.get_tx_stats()
-        self.assertEqual(c['packets'], 254)
+        self.assertEqual(p.tun_if.get_rx_stats(), 254)
+        self.assertEqual(p.tun_if.get_tx_stats(), 254)
 
         # bounce the interface state
         p.tun_if.admin_down()
@@ -2295,10 +2275,8 @@ class TestIpsec6TunProtect(TemplateIpsec,
         self.verify_tun_66(np3, np3, count=127)
         self.verify_drop_tun_66(np, count=127)
 
-        c = p.tun_if.get_rx_stats()
-        self.assertEqual(c['packets'], 127*9)
-        c = p.tun_if.get_tx_stats()
-        self.assertEqual(c['packets'], 127*8)
+        self.assertEqual(p.tun_if.get_rx_stats(), 127*9)
+        self.assertEqual(p.tun_if.get_tx_stats(), 127*8)
         self.unconfig_sa(np)
 
         # teardown
@@ -2316,10 +2294,8 @@ class TestIpsec6TunProtect(TemplateIpsec,
         self.config_protect(p)
 
         self.verify_tun_46(p, count=127)
-        c = p.tun_if.get_rx_stats()
-        self.assertEqual(c['packets'], 127)
-        c = p.tun_if.get_tx_stats()
-        self.assertEqual(c['packets'], 127)
+        self.assertEqual(p.tun_if.get_rx_stats(), 127)
+        self.assertEqual(p.tun_if.get_tx_stats(), 127)
 
         # teardown
         self.unconfig_protect(p)
@@ -2399,10 +2375,8 @@ class TestIpsec6TunProtectTun(TemplateIpsec,
 
         self.verify_tun_66(p, count=127)
 
-        c = p.tun_if.get_rx_stats()
-        self.assertEqual(c['packets'], 127)
-        c = p.tun_if.get_tx_stats()
-        self.assertEqual(c['packets'], 127)
+        self.assertEqual(p.tun_if.get_rx_stats(), 127)
+        self.assertEqual(p.tun_if.get_tx_stats(), 127)
 
         # rekey - create new SAs and update the tunnel protection
         np = copy.copy(p)
@@ -2419,10 +2393,8 @@ class TestIpsec6TunProtectTun(TemplateIpsec,
         self.unconfig_sa(p)
 
         self.verify_tun_66(np, count=127)
-        c = p.tun_if.get_rx_stats()
-        self.assertEqual(c['packets'], 254)
-        c = p.tun_if.get_tx_stats()
-        self.assertEqual(c['packets'], 254)
+        self.assertEqual(p.tun_if.get_rx_stats(), 254)
+        self.assertEqual(p.tun_if.get_tx_stats(), 254)
 
         # teardown
         self.unconfig_protect(np)
@@ -2581,29 +2553,23 @@ class TestIpsecItf4(TemplateIpsec,
         self.config_protect(p)
 
         self.verify_tun_44(p, count=n_pkts)
-        c = p.tun_if.get_rx_stats()
-        self.assertEqual(c['packets'], n_pkts)
-        c = p.tun_if.get_tx_stats()
-        self.assertEqual(c['packets'], n_pkts)
+        self.assertEqual(p.tun_if.get_rx_stats(), n_pkts)
+        self.assertEqual(p.tun_if.get_tx_stats(), n_pkts)
 
         p.tun_if.admin_down()
         self.verify_tun_dropped_44(p, count=n_pkts)
         p.tun_if.admin_up()
         self.verify_tun_44(p, count=n_pkts)
 
-        c = p.tun_if.get_rx_stats()
-        self.assertEqual(c['packets'], 3*n_pkts)
-        c = p.tun_if.get_tx_stats()
-        self.assertEqual(c['packets'], 2*n_pkts)
+        self.assertEqual(p.tun_if.get_rx_stats(), 3*n_pkts)
+        self.assertEqual(p.tun_if.get_tx_stats(), 2*n_pkts)
 
         # it's a v6 packet when its encrypted
         self.tun4_encrypt_node_name = "esp6-encrypt-tun"
 
         self.verify_tun_64(p, count=n_pkts)
-        c = p.tun_if.get_rx_stats()
-        self.assertEqual(c['packets'], 4*n_pkts)
-        c = p.tun_if.get_tx_stats()
-        self.assertEqual(c['packets'], 3*n_pkts)
+        self.assertEqual(p.tun_if.get_rx_stats(), 4*n_pkts)
+        self.assertEqual(p.tun_if.get_tx_stats(), 3*n_pkts)
 
         self.tun4_encrypt_node_name = "esp4-encrypt-tun"
 
@@ -2626,10 +2592,8 @@ class TestIpsecItf4(TemplateIpsec,
         self.unconfig_sa(p)
 
         self.verify_tun_44(np, count=n_pkts)
-        c = p.tun_if.get_rx_stats()
-        self.assertEqual(c['packets'], n_pkts)
-        c = p.tun_if.get_tx_stats()
-        self.assertEqual(c['packets'], n_pkts)
+        self.assertEqual(p.tun_if.get_rx_stats(), n_pkts)
+        self.assertEqual(p.tun_if.get_tx_stats(), n_pkts)
 
         # teardown
         self.unconfig_protect(np)
@@ -2662,7 +2626,6 @@ class TestIpsecItf4(TemplateIpsec,
         self.unconfig_sa(p)
         self.unconfig_network(p)
 
-
 class TemplateIpsecItf6(object):
     """ IPsec Interface IPv6 """
 
@@ -2754,29 +2717,23 @@ class TestIpsecItf6(TemplateIpsec,
         self.config_protect(p)
 
         self.verify_tun_66(p, count=n_pkts)
-        c = p.tun_if.get_rx_stats()
-        self.assertEqual(c['packets'], n_pkts)
-        c = p.tun_if.get_tx_stats()
-        self.assertEqual(c['packets'], n_pkts)
+        self.assertEqual(p.tun_if.get_rx_stats(), n_pkts)
+        self.assertEqual(p.tun_if.get_tx_stats(), n_pkts)
 
         p.tun_if.admin_down()
         self.verify_drop_tun_66(p, count=n_pkts)
         p.tun_if.admin_up()
         self.verify_tun_66(p, count=n_pkts)
 
-        c = p.tun_if.get_rx_stats()
-        self.assertEqual(c['packets'], 3*n_pkts)
-        c = p.tun_if.get_tx_stats()
-        self.assertEqual(c['packets'], 2*n_pkts)
+        self.assertEqual(p.tun_if.get_rx_stats(), 3*n_pkts)
+        self.assertEqual(p.tun_if.get_tx_stats(), 2*n_pkts)
 
         # it's a v4 packet when its encrypted
         self.tun6_encrypt_node_name = "esp4-encrypt-tun"
 
         self.verify_tun_46(p, count=n_pkts)
-        c = p.tun_if.get_rx_stats()
-        self.assertEqual(c['packets'], 4*n_pkts)
-        c = p.tun_if.get_tx_stats()
-        self.assertEqual(c['packets'], 3*n_pkts)
+        self.assertEqual(p.tun_if.get_rx_stats(), 4*n_pkts)
+        self.assertEqual(p.tun_if.get_tx_stats(), 3*n_pkts)
 
         self.tun6_encrypt_node_name = "esp6-encrypt-tun"
 
@@ -2799,17 +2756,14 @@ class TestIpsecItf6(TemplateIpsec,
         self.unconfig_sa(p)
 
         self.verify_tun_66(np, count=n_pkts)
-        c = p.tun_if.get_rx_stats()
-        self.assertEqual(c['packets'], n_pkts)
-        c = p.tun_if.get_tx_stats()
-        self.assertEqual(c['packets'], n_pkts)
+        self.assertEqual(p.tun_if.get_rx_stats(), n_pkts)
+        self.assertEqual(p.tun_if.get_tx_stats(), n_pkts)
 
         # teardown
         self.unconfig_protect(np)
         self.unconfig_sa(np)
         self.unconfig_network(p)
 
-
 class TestIpsecMIfEsp4(TemplateIpsec, IpsecTun4):
     """ Ipsec P2MP ESP v4 tests """
     tun4_encrypt_node_name = "esp4-encrypt-tun"
diff --git a/test/test_stats_client.py b/test/test_stats_client.py
index ced58710e..848be0465 100644
--- a/test/test_stats_client.py
+++ b/test/test_stats_client.py
@@ -5,6 +5,8 @@ import psutil
 from vpp_papi.vpp_stats import VPPStats
 
 from framework import VppTestCase, VppTestRunner
+from scapy.layers.l2 import Ether
+from scapy.layers.inet import IP
 
 
 class StatsClientTestCase(VppTestCase):
@@ -18,11 +20,17 @@ class StatsClientTestCase(VppTestCase):
     def tearDownClass(cls):
         super(StatsClientTestCase, cls).tearDownClass()
 
+    @classmethod
+    def setUpConstants(cls):
+        cls.extra_vpp_statseg_config = "per-node-counters on"
+        cls.extra_vpp_statseg_config += "update-interval 0.05"
+        super(StatsClientTestCase, cls).setUpConstants()
+
     def test_set_errors(self):
         """Test set errors"""
         self.assertEqual(self.statistics.set_errors(), {})
-        self.assertEqual(self.statistics.get_counter('/err/ethernet-input/no'),
-                         [0])
+        self.assertEqual(
+            self.statistics.get_counter('/err/ethernet-input/no error'), [0])
 
     def test_client_fd_leak(self):
         """Test file descriptor count - VPP-1486"""
@@ -42,6 +50,94 @@ class StatsClientTestCase(VppTestCase):
                          "ending client side file descriptor count: %s" % (
                              initial_fds, ending_fds))
 
+    def test_symlink_values(self):
+        """Test symlinks reported values"""
+        self.create_pg_interfaces(range(2))
+
+        for i in self.pg_interfaces:
+            i.admin_up()
+            i.config_ip4()
+            i.resolve_arp()
+
+        p = list()
+        for i in range(5):
+            packet = (Ether(src=self.pg0.remote_mac, dst=self.pg0.local_mac) /
+                      IP(src=self.pg0.remote_ip4, dst=self.pg1.remote_ip4))
+            p.append(packet)
+
+        self.send_and_expect(self.pg0, p, self.pg1)
+
+        pg1_tx = self.statistics.get_counter('/interfaces/pg1/tx')
+        if_tx = self.statistics.get_counter('/if/tx')
+
+        self.assertEqual(pg1_tx[0]['bytes'],
+                         if_tx[0][self.pg1.sw_if_index]['bytes'])
+        for i in self.pg_interfaces:
+            i.unconfig()
+            i.admin_down()
+
+    def test_symlink_add_del_interfaces(self):
+        """Test symlinks when adding and deleting interfaces"""
+        # We first create and delete interfaces
+        self.create_loopback_interfaces(1)
+        self.create_pg_interfaces(range(1))
+        self.loop0.remove_vpp_config()
+        self.create_pg_interfaces(range(2))
+
+        for i in self.pg_interfaces:
+            i.admin_up()
+            i.config_ip4()
+            i.resolve_arp()
+
+        p = list()
+        bytes_to_send = 0
+        for i in range(5):
+            packet = (Ether(src=self.pg0.remote_mac, dst=self.pg0.local_mac) /
+                      IP(src=self.pg0.remote_ip4, dst=self.pg1.remote_ip4))
+            bytes_to_send += len(packet)
+            p.append(packet)
+
+        tx_before_sending = self.statistics.get_counter('/interfaces/pg1/tx')
+        rx_before_sending = self.statistics.get_counter('/interfaces/pg0/rx')
+        self.send_and_expect(self.pg0, p, self.pg1)
+        tx = self.statistics.get_counter('/interfaces/pg1/tx')
+        rx = self.statistics.get_counter('/interfaces/pg0/rx')
+
+        # We wait for nodes symlinks to update (interfaces created/deleted).
+        # ... and packets to be sent
+        self.sleep(0.1)
+        vectors = self.statistics.get_counter('/nodes/pg1-tx/vectors')
+
+        self.assertEqual(tx[0]['bytes'] - tx_before_sending[0]['bytes'],
+                         bytes_to_send)
+        self.assertEqual(tx[0]['packets'] - tx_before_sending[0]['packets'],
+                         5)
+        self.assertEqual(rx[0]['bytes'] - rx_before_sending[0]['bytes'],
+                         bytes_to_send)
+        self.assertEqual(rx[0]['packets'] - rx_before_sending[0]['packets'],
+                         5)
+        self.assertEqual(vectors[0], rx[0]['packets'])
+
+        for i in self.pg_interfaces:
+            i.unconfig()
+            i.admin_down()
+
+    def test_index_consistency(self):
+        """Test index consistency despite changes in the stats"""
+        d = self.statistics.ls(['/if/names'])
+        self.create_loopback_interfaces(10)
+        for i in range(10):
+            try:
+                s = self.statistics.dump(d)
+                break
+            except:
+                pass
+        k, v = s.popitem()
+        self.assertEqual(len(v), 11)
+
+        for i in self.lo_interfaces:
+            i.remove_vpp_config()
+
     @unittest.skip("Manual only")
     def test_mem_leak(self):
         def loop():
diff --git a/test/vpp_interface.py b/test/vpp_interface.py
index 32d8166fc..1cbe76aa6 100644
--- a/test/vpp_interface.py
+++ b/test/vpp_interface.py
@@ -475,12 +475,12 @@ class VppInterface(metaclass=abc.ABCMeta):
         return self.name
 
     def get_rx_stats(self):
-        c = self.test.statistics.get_counter("^/if/rx$")
-        return c[0][self.sw_if_index]
+        return (self.test.statistics["/if/rx"]
+                [:, self.sw_if_index].sum_packets())
 
     def get_tx_stats(self):
-        c = self.test.statistics.get_counter("^/if/tx$")
-        return c[0][self.sw_if_index]
+        return (self.test.statistics["/if/tx"]
+                [:, self.sw_if_index].sum_packets())
 
     def set_l3_mtu(self, mtu):
         self.test.vapi.sw_interface_set_mtu(self.sw_if_index, [mtu, 0, 0, 0])
diff --git a/test/vpp_neighbor.py b/test/vpp_neighbor.py
index 6f5426180..9ba87005c 100644
--- a/test/vpp_neighbor.py
+++ b/test/vpp_neighbor.py
@@ -83,5 +83,5 @@ class VppNeighbor(VppObject):
         return ("%d:%s" % (self.sw_if_index, self.nbr_addr))
 
     def get_stats(self):
-        c = self._test.statistics.get_counter("/net/adjacency")
+        c = self._test.statistics["/net/adjacency"]
         return c[0][self.stats_index]
-- 
2.24.3 (Apple Git-128)

